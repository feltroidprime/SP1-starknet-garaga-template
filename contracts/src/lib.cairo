//! # SP1 Starknet Verification Contract
//! 
//! This contract demonstrates how to verify SP1 zero-knowledge proofs on Starknet
//! using the Garaga SP1 Verifier library. It provides a simple interface for
//! verifying Groth16 proofs generated by SP1 programs.
//! 
//! ## Features
//! - Verify SP1 Groth16 proofs on-chain
//! - Validate proofs against specific SP1 programs
//! - Extract and return public inputs from valid proofs
//! 
//! ## Usage
//! Deploy this contract and call `verify_sp1_proof` with properly formatted
//! proof calldata generated by the SP1 proof generation scripts.

/// Interface for SP1 proof verification on Starknet.
/// 
/// This interface provides methods to verify SP1 zero-knowledge proofs
/// and extract their public inputs when verification succeeds.
#[starknet::interface]
pub trait IHelloStarknet<TContractState> {
    /// Verify an SP1 Groth16 proof against the expected program.
    /// 
    /// This function validates that:
    /// 1. The proof is cryptographically valid (via Garaga verifier)
    /// 2. The proof corresponds to the expected SP1 program
    /// 
    /// # Arguments
    /// * `proof` - Array of felt252 values representing the Groth16 proof calldata
    /// 
    /// # Returns
    /// * `Option<Span<u256>>` - Some(public_inputs) if proof is valid, None if invalid
    /// 
    fn verify_sp1_proof(ref self: TContractState, proof: Array<felt252>) -> Option<Span<u256>>;
}

/// SP1 Proof Verification Contract
/// 
/// This contract integrates with the Garaga SP1 Verifier to provide
/// on-chain verification of SP1 zero-knowledge proofs on Starknet.
/// 
/// The contract maintains a reference to a specific SP1 program and
/// only accepts proofs generated for that program, ensuring that
/// verified computations match the expected logic.
#[starknet::contract]
mod HelloStarknet {
    use starknet::SyscallResultTrait;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use starknet::syscalls::library_call_syscall;

    /// Contract storage for maintaining verification state
    #[storage]
    struct Storage {
        /// Stores the last Fibonacci number computed (example usage)
        /// This demonstrates how you might store computation results
        last_fibonacci_n: u256,
    }

    /// SP1 Verifier class hash deployed and maintained by the Garaga library.
    /// 
    /// This class hash points to the Garaga SP1 Verifier contract that handles
    /// the cryptographic verification of Groth16 proofs. The verifier is available
    /// on both Starknet mainnet and Sepolia testnet.
    /// 
    /// **Important**: Always use the latest version from:
    /// https://garaga.gitbook.io/garaga/maintained-smart-contracts
    const SP1_VERIFIER_CLASS_HASH: felt252 =
        0x5d147e9fcb648e847da819287b8f462ce9416419240c64d35640dcba35e127;

    /// Verification key for the specific SP1 program this contract accepts.
    /// 
    /// This key uniquely identifies the SP1 program (Fibonacci computation in this example).
    /// Only proofs generated for this specific program will be accepted by the contract.
    /// 
    /// **To update**: Run `cargo run --release --bin vkey` in the script directory
    /// to generate the verification key for your SP1 program.
    const SP1_PROGRAM: u256 = 0x00ee2a4a1c9c659ed802a544aa469136e72e1a1538af94fce56705576b48f247;

    #[abi(embed_v0)]
    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {
        /// Verify an SP1 Groth16 proof and extract public inputs.
        /// 
        /// This function performs a two-step verification process:
        /// 1. Cryptographic verification via the Garaga SP1 Verifier
        /// 2. Program verification to ensure the proof matches our expected SP1 program
        /// 
        /// # Arguments
        /// * `proof` - Groth16 proof calldata as an array of felt252 values
        /// 
        /// # Returns
        /// * `Option<Span<u256>>` - Public inputs if verification succeeds, None otherwise
        /// 
        /// # Panics
        /// * If the proof is valid but for a different SP1 program ('Wrong program')
        /// * If the library call to the verifier fails
        fn verify_sp1_proof(ref self: ContractState, proof: Array<felt252>) -> Option<Span<u256>> {
            // Step 1: Call the Garaga SP1 Verifier to validate the proof cryptographically
            // This verifies the Groth16 proof structure and cryptographic validity
            let mut result_serialized = library_call_syscall(
                SP1_VERIFIER_CLASS_HASH.try_into().unwrap(),
                selector!("verify_sp1_groth16_proof_bn254"),
                proof.span(),
            )
                .unwrap_syscall();

            // Step 2: Deserialize the verification result
            // The verifier returns Option<(verification_key, public_inputs)>
            let result = Serde::<Option<(u256, Span<u256>)>>::deserialize(ref result_serialized)
                .unwrap();

            // Step 3: Check if cryptographic verification succeeded
            if result.is_none() {
                return None;
            }

            // Step 4: Extract verification key and public inputs
            let (vk, public_inputs) = result.unwrap();

            // Step 5: Verify this proof corresponds to our expected SP1 program
            // This ensures we only accept proofs for the specific computation we expect
            assert(vk == SP1_PROGRAM, 'Wrong program');

            // Step 6: Return the public inputs for the verified computation
            // These inputs represent the publicly committed values from the SP1 program
            Some(public_inputs)
        }
    }
}
