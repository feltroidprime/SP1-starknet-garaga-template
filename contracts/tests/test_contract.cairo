//! # SP1 Starknet Verification Contract Tests
//! 
//! This module contains comprehensive tests for the SP1 proof verification contract.
//! The tests use Starknet Foundry's fork testing feature to verify proofs against
//! the actual Garaga SP1 Verifier deployed on Sepolia testnet.
//! 
//! ## Test Strategy
//! - Use real proof fixtures generated by the SP1 proof generation scripts
//! - Fork Sepolia testnet to access the deployed Garaga verifier
//! - Test both positive (valid proof) and negative (invalid proof) cases

use snforge_std::fs::{File, FileTrait, read_txt};
use snforge_std::{ContractClassTrait, DeclareResultTrait, declare};
use sp1_app::{
    IHelloStarknetDispatcher, IHelloStarknetDispatcherTrait, IHelloStarknetSafeDispatcher,
    IHelloStarknetSafeDispatcherTrait,
};
use starknet::ContractAddress;

/// Deploy the HelloStarknet contract for testing.
/// 
/// This function declares and deploys a new instance of the HelloStarknet contract
/// with default constructor arguments (empty array).
/// 
/// # Arguments
/// * `name` - The contract name to declare and deploy
/// 
/// # Returns
/// * `ContractAddress` - The address of the deployed contract
/// 
/// # Example
/// ```cairo
/// let contract_address = deploy_contract("HelloStarknet");
/// let dispatcher = IHelloStarknetDispatcher { contract_address };
/// ```
fn deploy_contract(name: ByteArray) -> ContractAddress {
    let contract = declare(name).unwrap().contract_class();
    let (contract_address, _) = contract.deploy(@ArrayTrait::new()).unwrap();
    contract_address
}

/// Test SP1 proof verification with a valid Groth16 proof.
/// 
/// This test demonstrates the complete verification flow:
/// 1. Deploy the verification contract
/// 2. Load a pre-generated proof fixture
/// 3. Verify the proof on-chain
/// 4. Assert that verification succeeds
/// 
/// ## Test Setup
/// - Uses fork testing against Sepolia testnet to access the Garaga verifier
/// - Loads proof calldata from `src/fixtures/groth16-calldata.txt`
/// - The fixture is generated by running the proof generation script
/// 
/// ## Prerequisites
/// Before running this test, ensure you have:
/// 1. Generated a proof: `cd ../script && cargo run --release --bin starknet -- --system groth16`
/// 2. Updated the SP1_PROGRAM constant in the contract to match your verification key
/// 
/// ## Expected Behavior
/// - The proof should verify successfully
/// - The function should return Some(public_inputs) containing the Fibonacci computation results
/// - No panics or assertion failures should occur
#[test]
#[fork(url: "https://starknet-sepolia.public.blastapi.io/rpc/v0_8", block_tag: latest)]
fn test_verify_sp1_proof() {
    // Step 1: Deploy the verification contract
    let contract_address = deploy_contract("HelloStarknet");
    let dispatcher = IHelloStarknetDispatcher { contract_address };

    // Step 2: Load the proof fixture generated by the script
    // This file contains the Groth16 proof calldata formatted for Starknet
    let file = FileTrait::new("src/fixtures/groth16-calldata.txt");
    let calldata = read_txt(@file);

    // Step 3: Verify the proof on-chain
    // This calls the contract's verify_sp1_proof function with the loaded proof data
    let result = dispatcher.verify_sp1_proof(calldata);

    // Step 4: Assert that verification succeeded
    // A valid proof should return Some(public_inputs), not None
    assert(result.is_some(), 'Proof is invalid');

    // Optional: You can also verify the public inputs contain expected values
    // let public_inputs = result.unwrap();
    // assert(public_inputs.len() > 0, 'No public inputs');
    // Additional assertions on the public input values can be added here
}